{"id":"collection.ts","dependencies":[{"name":"/home/phoenix/Desktop/Projects/CargoDB/package.json","includedInParent":true,"mtime":1588969379438},{"name":"./async","loc":{"line":22,"column":38},"parent":"/home/phoenix/Desktop/Projects/CargoDB/src/collection.ts","resolved":"/home/phoenix/Desktop/Projects/CargoDB/src/async.ts"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs_1 = __importDefault(require(\"fs\"));\nvar path_1 = __importDefault(require(\"path\"));\nvar shortid_1 = __importDefault(require(\"shortid\"));\nvar async_1 = __importDefault(require(\"./async\"));\nvar Collection = /** @class */ (function (_super) {\n    __extends(Collection, _super);\n    function Collection(loc, name, rusty) {\n        var _this = _super.call(this, _this) || this;\n        // Set global variables\n        _this.path = loc;\n        _this.name = name;\n        _this.rusty = rusty;\n        // If ship does not\n        // exist then create one\n        if (!fs_1.default.existsSync(loc)) {\n            fs_1.default.mkdirSync(loc);\n        }\n        return _this;\n    }\n    // Add a cargo file\n    // to the ship and\n    // return generated ID\n    Collection.prototype.addCargo = function (cargo) {\n        if (cargo.ID != null) {\n            throw \"\\n                Cannot add an element with \\n                existing ID field (\" + cargo.ID + \")\\n            \";\n        }\n        var genID = shortid_1.default.generate();\n        // Location of the future cargo file\n        var loc = path_1.default.join(this.path, genID + '.cargo');\n        // what if such file exists and screwed screwed the job\n        // This won't happen tho (99.99% of the time)\n        if (fs_1.default.existsSync(loc)) {\n            genID = shortid_1.default.generate();\n        }\n        // Set the ID to the cargo\n        cargo.ID = genID;\n        // Create a JSON out of the given cargo\n        var json = JSON.stringify(cargo);\n        // Save Cargo file\n        fs_1.default.writeFileSync(loc, json);\n        return genID;\n    };\n    // Get a cargo file\n    // from the ship \n    // by id\n    Collection.prototype.getCargo = function (id) {\n        var isValid = shortid_1.default.isValid(id);\n        if (!isValid) {\n            throw \"Given ID is invalid (\" + id + \")\";\n        }\n        // Location to the desired cargo\n        var loc = path_1.default.join(this.path, id + '.cargo');\n        // If such cargo does not exist\n        if (!fs_1.default.existsSync(loc)) {\n            console.error(\"CargoDB couldn't find such cargo id: \" + id);\n            return null;\n        }\n        // Read JSON carefully\n        try {\n            return JSON.parse(fs_1.default.readFileSync(loc, 'utf-8'));\n        }\n        // What if it fails to read?\n        catch (err) {\n            var rusty = path_1.default.join(this.path, id + '.rusty.cargo');\n            // If there is rusty cargo handler\n            // notify user otherwise\n            this.rusty(path_1.default.join(this.dir, id));\n            // Do the rename\n            fs_1.default.renameSync(loc, rusty);\n            return null;\n        }\n    };\n    // filter the cargos\n    // that you need\n    Collection.prototype.findCargos = function (callback) {\n        var matches = [];\n        var files = fs_1.default.readdirSync(this.path);\n        // Iterate over files\n        for (var i = 0; i < files.length; i++) {\n            var loc = path_1.default.join(this.path, files[i]);\n            var raw = fs_1.default.readFileSync(loc, 'utf-8');\n            // Read JSON and be careful\n            try {\n                var obj = JSON.parse(raw);\n                if (callback(obj)) {\n                    matches.push(obj);\n                }\n            }\n            // What if it fails to read?\n            catch (err) {\n                // Only if JSON failes to parse\n                if (err instanceof SyntaxError) {\n                    // Get only name of the file\n                    var name = path_1.default.basename(files[i], path_1.default.extname(files[i]));\n                    var rusty = path_1.default.join(this.path, name + '.rusty.cargo');\n                    // If there is rusty cargo handler\n                    // notify user otherwise\n                    this.rusty(path_1.default.join(this.dir, id));\n                    // Do the rename\n                    fs_1.default.renameSync(loc, rusty);\n                }\n            }\n        }\n        return matches;\n    };\n    // Set an existing cargo file\n    // to a certain cargo\n    Collection.prototype.setCargo = function (id, cargo) {\n        var isValid = shortid_1.default.isValid(id);\n        if (!isValid) {\n            throw \"Given ID is invalid (\" + id + \")\";\n        }\n        // Location to the desired cargo\n        var loc = path_1.default.join(this.path, id + '.cargo');\n        // If such cargo does not exist\n        if (!fs_1.default.existsSync(loc)) {\n            console.error(\"CargoDB couldn't find such cargo id: \" + id);\n            return null;\n        }\n        // Write JSON cargo\n        cargo.ID = id;\n        var json = JSON.stringify(cargo);\n        // Save cargo\n        fs_1.default.writeFileSync(loc, json);\n        return id;\n    };\n    // Update given fields\n    // (fields with\n    // undefined values\n    // will be removed)\n    Collection.prototype.updateCargo = function (id, cargo) {\n        var isValid = shortid_1.default.isValid(id);\n        if (!isValid) {\n            throw \"Given ID is invalid (\" + id + \")\";\n        }\n        // Location to the desired cargo\n        var loc = path_1.default.join(this.path, id + '.cargo');\n        // If such cargo does not exist\n        if (!fs_1.default.existsSync(loc)) {\n            console.error(\"CargoDB couldn't find such cargo id: \" + id);\n            return null;\n        }\n        // Read JSON carefully\n        try {\n            var obj = JSON.parse(fs_1.default.readFileSync(loc, 'utf-8'));\n            // Update values\n            for (var item in cargo) {\n                if (item == 'ID')\n                    continue;\n                // Update item\n                obj[item] = cargo[item];\n                // Remove if it's supposed to be undefined\n                if (cargo[item] === undefined) {\n                    delete obj[item];\n                }\n            }\n            var json = JSON.stringify(obj);\n            fs_1.default.writeFileSync(loc, json);\n            return id;\n        }\n        // What if it fails to read?\n        catch (err) {\n            // Only if JSON failes to parse\n            if (err instanceof SyntaxError) {\n                var rusty = path_1.default.join(this.path, id + '.rusty.cargo');\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path_1.default.join(this.dir, id));\n                // Do the rename\n                fs_1.default.renameSync(loc, rusty);\n                return null;\n            }\n        }\n    };\n    // Remove the cargo\n    // from collection\n    Collection.prototype.removeCargo = function (id) {\n        var isValid = shortid_1.default.isValid(id);\n        if (!isValid) {\n            throw \"Given ID is invalid (\" + id + \")\";\n        }\n        // Location to the desired cargo\n        var loc = path_1.default.join(this.path, id + '.cargo');\n        // If such cargo does not exist\n        if (!fs_1.default.existsSync(loc)) {\n            console.error(\"CargoDB couldn't find such cargo id: \" + id);\n            return null;\n        }\n        fs_1.default.unlinkSync(loc);\n        return id;\n    };\n    return Collection;\n}(async_1.default));\n// Async wrapper \n// for Cargo's Collection.\n// Don't write any logic here\n// async wrapper's purpose is to\n// handle the code that needs to\n// be done asynchronously\nvar CollectionAsync = /** @class */ (function (_super) {\n    __extends(CollectionAsync, _super);\n    // Collection constructor\n    function CollectionAsync(loc, name, rusty) {\n        return _super.call(this, loc, name, rusty) || this;\n    }\n    // Expose methods in a \n    // simple to use API\n    // [Async] It's is used to\n    // add cargo to the collection.\n    // The object can be any type\n    // or should follow a schema\n    // defined optionally in\n    // collection constructor\n    CollectionAsync.prototype.add = function (cargo) {\n        return _super.prototype.async.call(this, 'addCargo', [cargo]);\n    };\n    // [Sync] It retrieves\n    // desired cargo by it's id.\n    // If one doesn't exits\n    // a null value is\n    // being returned\n    CollectionAsync.prototype.get = function (id) {\n        return _super.prototype.getCargo.call(this, id);\n    };\n    // [Sync] It seeks for\n    // cargos that match\n    // given criteria resolved\n    // in a callback function.\n    // It always returns an array\n    // even if nothing was found\n    CollectionAsync.prototype.find = function (callback) {\n        return _super.prototype.findCargos.call(this, callback);\n    };\n    // [Async] it searches\n    // cargo of given ID and\n    // overwrites it's contents.\n    // If the cargo doesn't exist\n    // returns null value\n    CollectionAsync.prototype.set = function (id, cargo) {\n        return _super.prototype.async.call(this, 'setCargo', [id, cargo]);\n    };\n    // [Async] It commits\n    // a mutation on a cargo\n    // ruled by cargo object\n    // config. In another words\n    // merges the old cargo with\n    // the new data model\n    CollectionAsync.prototype.update = function (id, cargo) {\n        return _super.prototype.async.call(this, 'updateCargo', [id, cargo]);\n    };\n    // [Async] It removes\n    // a cargo that is found\n    // by ID. As always - null\n    // value indicates that \n    // the cargo wasn't found\n    CollectionAsync.prototype.remove = function (id) {\n        return _super.prototype.async.call(this, 'removeCargo', [id]);\n    };\n    return CollectionAsync;\n}(Collection));\nexports.default = CollectionAsync;\n"},"sourceMaps":{"js":{"version":3,"file":"collection.js","sourceRoot":"","sources":["collection.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport shortid from 'shortid'\nimport AsyncNature from './async'\n\nclass Collection extends AsyncNature {\n    constructor(loc: string, name: string, rusty: Function) {\n        super(this)\n        // Set global variables\n        this.path = loc\n        this.name = name\n        this.rusty = rusty\n        // If ship does not\n        // exist then create one\n        if (!fs.existsSync(loc)) {\n            fs.mkdirSync(loc)\n        }\n    }\n\n    // Add a cargo file\n    // to the ship and\n    // return generated ID\n    public addCargo(cargo: Object): string {\n        if (cargo.ID != null) {\n            throw `\n                Cannot add an element with \n                existing ID field (${cargo.ID})\n            `\n        }\n        const genID = shortid.generate()\n            // Location of the future cargo file\n        const loc = path.join(this.path, genID + '.cargo')\n\n        // what if such file exists and screwed screwed the job\n        // This won't happen tho (99.99% of the time)\n        if (fs.existsSync(loc)) {\n            genID = shortid.generate()\n        }\n\n        // Set the ID to the cargo\n        cargo.ID = genID\n            // Create a JSON out of the given cargo\n        const json = JSON.stringify(cargo)\n\n        // Save Cargo file\n        fs.writeFileSync(loc, json)\n        return genID\n    }\n\n    // Get a cargo file\n    // from the ship \n    // by id\n    public getCargo(id: string): Object | null {\n        let isValid = shortid.isValid(id)\n        if (!isValid) {\n            throw `Given ID is invalid (${id})`\n        }\n        // Location to the desired cargo\n        const loc = path.join(this.path, id + '.cargo')\n            // If such cargo does not exist\n        if (!fs.existsSync(loc)) {\n            console.error(`CargoDB couldn't find such cargo id: ${id}`)\n            return null\n        }\n        // Read JSON carefully\n        try {\n            return JSON.parse(fs.readFileSync(loc, 'utf-8'))\n        }\n        // What if it fails to read?\n        catch (err) {\n            const rusty = path.join(this.path, id + '.rusty.cargo')\n            // If there is rusty cargo handler\n            // notify user otherwise\n            this.rusty(path.join(this.dir, id))\n            // Do the rename\n            fs.renameSync(loc, rusty)\n            return null\n        }\n    }\n\n    // filter the cargos\n    // that you need\n    public findCargos(callback: (cargo: Object) => boolean): Array<Object> {\n        const matches = []\n        let files = fs.readdirSync(this.path)\n            // Iterate over files\n        for (let i = 0; i < files.length; i++) {\n            const loc = path.join(this.path, files[i])\n            const raw = fs.readFileSync(loc, 'utf-8')\n                // Read JSON and be careful\n            try {\n                const obj = JSON.parse(raw)\n                if (callback(obj)) {\n                    matches.push(obj)\n                }\n            }\n            // What if it fails to read?\n            catch (err) {\n                // Only if JSON failes to parse\n                if (err instanceof SyntaxError) {\n                    // Get only name of the file\n                    const name = path.basename(files[i], path.extname(files[i]))\n                    const rusty = path.join(this.path, name + '.rusty.cargo')\n                    // If there is rusty cargo handler\n                    // notify user otherwise\n                    this.rusty(path.join(this.dir, id))\n                    // Do the rename\n                    fs.renameSync(loc, rusty)\n                }\n            }\n        }\n        return matches\n    }\n\n    // Set an existing cargo file\n    // to a certain cargo\n    public setCargo(id: string, cargo: Object): string | null {\n        let isValid = shortid.isValid(id)\n        if (!isValid) {\n            throw `Given ID is invalid (${id})`\n        }\n        // Location to the desired cargo\n        const loc = path.join(this.path, id + '.cargo')\n            // If such cargo does not exist\n        if (!fs.existsSync(loc)) {\n            console.error(`CargoDB couldn't find such cargo id: ${id}`)\n            return null\n        }\n        // Write JSON cargo\n        cargo.ID = id\n        const json = JSON.stringify(cargo)\n            // Save cargo\n        fs.writeFileSync(loc, json)\n        return id\n    }\n\n    // Update given fields\n    // (fields with\n    // undefined values\n    // will be removed)\n    public updateCargo(id: string, cargo: Object): string | null {\n        let isValid = shortid.isValid(id)\n        if (!isValid) {\n            throw `Given ID is invalid (${id})`\n        }\n        // Location to the desired cargo\n        const loc = path.join(this.path, id + '.cargo')\n            // If such cargo does not exist\n        if (!fs.existsSync(loc)) {\n            console.error(`CargoDB couldn't find such cargo id: ${id}`)\n            return null\n        }\n        // Read JSON carefully\n        try {\n            let obj = JSON.parse(fs.readFileSync(loc, 'utf-8'))\n                // Update values\n            for (const item in cargo) {\n                if (item == 'ID') continue\n                    // Update item\n                obj[item] = cargo[item]\n                    // Remove if it's supposed to be undefined\n                if (cargo[item] === undefined) {\n                    delete obj[item]\n                }\n            }\n            const json = JSON.stringify(obj)\n            fs.writeFileSync(loc, json)\n            return id\n        }\n        // What if it fails to read?\n        catch (err) {\n            // Only if JSON failes to parse\n            if (err instanceof SyntaxError) {\n                const rusty = path.join(this.path, id + '.rusty.cargo')\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path.join(this.dir, id))\n                // Do the rename\n                fs.renameSync(loc, rusty)\n                return null\n            }\n        }\n    }\n\n    // Remove the cargo\n    // from collection\n    public removeCargo(id: string): string | null {\n        let isValid = shortid.isValid(id)\n        if (!isValid) {\n            throw `Given ID is invalid (${id})`\n        }\n        // Location to the desired cargo\n        const loc = path.join(this.path, id + '.cargo')\n        // If such cargo does not exist\n        if (!fs.existsSync(loc)) {\n            console.error(`CargoDB couldn't find such cargo id: ${id}`)\n            return null\n        }\n        fs.unlinkSync(loc)\n        return id\n    }\n}\n\n\n// Async wrapper \n// for Cargo's Collection.\n// Don't write any logic here\n// async wrapper's purpose is to\n// handle the code that needs to\n// be done asynchronously\n\nclass CollectionAsync extends Collection {\n\n    // Collection constructor\n    constructor(loc: string, name: string, rusty: Function) {\n        super(loc, name, rusty)\n    }\n\n    // Expose methods in a \n    // simple to use API\n\n    // [Async] It's is used to\n    // add cargo to the collection.\n    // The object can be any type\n    // or should follow a schema\n    // defined optionally in\n    // collection constructor\n    public add(cargo: Object): string {\n        return super.async('addCargo', [cargo])\n    }\n\n    // [Sync] It retrieves\n    // desired cargo by it's id.\n    // If one doesn't exits\n    // a null value is\n    // being returned\n    public get(id: string): Object | null {\n        return super.getCargo(id)\n    }\n\n    // [Sync] It seeks for\n    // cargos that match\n    // given criteria resolved\n    // in a callback function.\n    // It always returns an array\n    // even if nothing was found\n    public find(callback: (cargo: Object) => boolean): Array<Object> {\n        return super.findCargos(callback)\n    }\n\n    // [Async] it searches\n    // cargo of given ID and\n    // overwrites it's contents.\n    // If the cargo doesn't exist\n    // returns null value\n    public set(id: string, cargo: Object): string | null {\n        return super.async('setCargo', [id, cargo])\n    }\n\n    // [Async] It commits\n    // a mutation on a cargo\n    // ruled by cargo object\n    // config. In another words\n    // merges the old cargo with\n    // the new data model\n    public update(id: string, cargo: Object): string | null {\n        return super.async('updateCargo', [id, cargo])\n    }\n\n    // [Async] It removes\n    // a cargo that is found\n    // by ID. As always - null\n    // value indicates that \n    // the cargo wasn't found\n    public remove(id: string): string | null {\n        return super.async('removeCargo', [id])\n    }\n}\n\nexport default CollectionAsync"]}},"error":null,"hash":"e11e730407037134bc3aa4856ad1821c","cacheData":{"env":{}}}