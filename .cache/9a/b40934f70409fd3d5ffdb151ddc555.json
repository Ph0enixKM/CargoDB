{"id":"cargo.ts","dependencies":[{"name":"/home/phoenix/Desktop/Projects/CargoDB/package.json","includedInParent":true,"mtime":1588969379438},{"name":"./collection","loc":{"line":22,"column":43},"parent":"/home/phoenix/Desktop/Projects/CargoDB/src/cargo.ts","resolved":"/home/phoenix/Desktop/Projects/CargoDB/src/collection.ts"},{"name":"./async","loc":{"line":23,"column":38},"parent":"/home/phoenix/Desktop/Projects/CargoDB/src/cargo.ts","resolved":"/home/phoenix/Desktop/Projects/CargoDB/src/async.ts"},{"name":"./helper","loc":{"line":24,"column":39},"parent":"/home/phoenix/Desktop/Projects/CargoDB/src/cargo.ts","resolved":"/home/phoenix/Desktop/Projects/CargoDB/src/helper.ts"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs_1 = __importDefault(require(\"fs\"));\nvar path_1 = __importDefault(require(\"path\"));\nvar shortid_1 = __importDefault(require(\"shortid\"));\nvar collection_1 = __importDefault(require(\"./collection\"));\nvar async_1 = __importDefault(require(\"./async\"));\nvar helper_1 = __importDefault(require(\"./helper\"));\n// Main Cargo idea.\n// All user ready-to-use \n// methods put here.\nvar Cargo = /** @class */ (function (_super) {\n    __extends(Cargo, _super);\n    function Cargo(name, dir) {\n        var _this = _super.call(this, _this) || this;\n        // Get path relative to the directory\n        if (dir && dir[0] === '~') {\n            dir = path_1.default.join(process.env.PWD, dir.slice(1));\n        }\n        // Provide a storage name 'string'\n        _this.name = name || (function () { throw 'No storage name provided'; })();\n        // Provide storage's location (optional) 'string'\n        _this.dir = dir || process.env.PWD;\n        // Create Base Folder Storage\n        helper_1.default.createBase(_this);\n        // Generate a better charset\n        shortid_1.default.characters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#$');\n        // Set default behavior for rusty containers\n        _this.rusty = function (location) {\n            var name = path_1.default.basename(location);\n            console.error(helper_1.default.textFormat(\"\\n                CargoDB stumbled upon a corrupted .cargo file.\\n                In order to keep functioning the file is being renamed to\\n                '\" + name + \".rusty.cargo'.\\n            \"));\n        };\n        // Create variable to store all schemas\n        _this.schemas = {};\n        return _this;\n    }\n    // Whenever rusty container is found\n    // Run this callback with the path\n    Cargo.prototype.onRusty = function (cb) {\n        this.rusty = cb;\n    };\n    // Set Item Method\n    // storage : String\n    // item : Any\n    Cargo.prototype.setCargo = function (storage, item) {\n        var _a, _b;\n        // Location to the cargo file\n        var loc = path_1.default.join(this.dir, this.name, storage + '.cargo');\n        // Validate if given name is correct\n        if (!helper_1.default.validateName(storage)) {\n            throw \"\\n          Given name '\" + storage + \"' does not apply \\n          to proper key name pattern\\n          (RegExp: /^[A-Za-z0-9@$-#%&_()[]{}]+$/)\\n        \";\n        }\n        // Create container if does not exist\n        if (!fs_1.default.existsSync(loc)) {\n            fs_1.default.writeFileSync(loc, '{}');\n        }\n        // Get the already existing file\n        var objectContainer = fs_1.default.readFileSync(loc, 'utf-8');\n        // If it's a new file\n        if (objectContainer == null) {\n            fs_1.default.writeFileSync(loc, JSON.stringify((_a = {},\n                _a[storage] = item,\n                _a)));\n        }\n        // if the file actually exists \n        // to just \"append\" the data\n        else {\n            try {\n                // Try to parse JSON inside of the file\n                objectContainer = JSON.parse(objectContainer);\n                objectContainer[storage] = item;\n                fs_1.default.writeFileSync(loc, JSON.stringify(objectContainer));\n            }\n            // if the data is corrupted\n            catch (err) {\n                // Location to the rusty cargo file\n                var rusty = path_1.default.join(this.dir, this.name, storage + '.rusty.cargo');\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path_1.default.join(this.dir, this.name, storage));\n                // Do the rename\n                fs_1.default.renameSync(loc, rusty);\n                // Save the value anyways\n                fs_1.default.writeFileSync(loc, JSON.stringify((_b = {}, _b[storage] = item, _b)));\n                return false;\n            }\n        }\n        return true;\n    };\n    // Get Item Method\n    // storage : String\n    Cargo.prototype.getCargo = function (storage) {\n        // Location to the cargo file\n        var loc = path_1.default.join(this.dir, this.name, storage + '.cargo');\n        // Validate if given name is correct\n        if (!helper_1.default.validateName(storage)) {\n            throw \"\\n                Given name '\" + storage + \"' does not apply \\n                to proper key name pattern\\n                (RegExp: /^[A-Za-z0-9@$-#%&_()[]{}]+$/)\\n            \";\n        }\n        // If not exists then return undefined\n        if (fs_1.default.existsSync(loc)) {\n            try {\n                // Try to parse JSON inside of the file\n                var objectContainer = JSON.parse(fs_1.default.readFileSync(loc, 'utf-8'));\n                return objectContainer[storage];\n            }\n            // if the data is corrupted\n            catch (err) {\n                // Location to the rusty cargo file\n                var rusty = path_1.default.join(this.dir, this.name, storage + '.rusty.cargo');\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path_1.default.join(this.dir, this.name, storage));\n                // Do the rename\n                fs_1.default.renameSync(loc, rusty);\n                return null;\n            }\n        }\n        return null;\n    };\n    // Get a collection (any)\n    // name : String\n    Cargo.prototype.in = function (name) {\n        // Location to the collection dir\n        var loc = path_1.default.join(this.dir, this.name, name);\n        // Validate if given name is correct\n        if (!helper_1.default.validateName(name)) {\n            throw \"\\n                Given name '\" + name + \"' does not apply \\n                to proper key name pattern\\n                (RegExp: /^[A-Za-z0-9@$-#%&_()[]{}]+$/)\\n            \";\n        }\n        if (this.schemas[name] == null) {\n            throw \"\\n                There is no collection with name: '\" + name + \"'\\n                If this name is not a mistake,\\n                create one with cargo.create()\\n                (More info in docs)\\n            \";\n        }\n        return new collection_1.default(loc, name, this.rusty, this.schemas[name]);\n    };\n    // Create a collection\n    // Possibly with a schema\n    Cargo.prototype.create = function (name, schema) {\n        // Location to the collection dir\n        var loc = path_1.default.join(this.dir, this.name, name);\n        // Create dir if not exists\n        if (!fs_1.default.existsSync(loc)) {\n            fs_1.default.mkdirSync(loc);\n        }\n        // Create generic schema if nothing provided\n        if (schema == null)\n            this.schemas[name] = 'no-schema';\n    };\n    return Cargo;\n}(async_1.default));\n// Async wrapper \n// for Cargo database.\n// Don't write any logic here\n// async wrapper's purpose is to\n// handle the code that needs to\n// be done asynchronously\nvar CargoAsync = /** @class */ (function (_super) {\n    __extends(CargoAsync, _super);\n    // Cargo constructor\n    function CargoAsync(name, path) {\n        return _super.call(this, name, path) || this;\n    }\n    // Expose methods in a \n    // simple to use API\n    // Create a synchronous version of Cargo.\n    // Warning: possible collisions may occur\n    CargoAsync.Sync = function (name, path) {\n        return new Cargo(name, path);\n    };\n    // [Async] This method is used \n    // to set cargo to any value.\n    // The item can be any type.\n    CargoAsync.prototype.set = function (storage, item) {\n        return _super.prototype.async.call(this, 'setCargo', [storage, item]);\n    };\n    // [Sync] This method is used to \n    // retrieve data from a cargo.\n    // Returned null value means\n    // the cargo doesn't exist\n    CargoAsync.prototype.get = function (storage) {\n        return _super.prototype.getCargo.call(this, storage);\n    };\n    return CargoAsync;\n}(Cargo));\nexports.default = CargoAsync;\nmodule.exports = CargoAsync;\n"},"sourceMaps":{"js":{"version":3,"file":"cargo.js","sourceRoot":"","sources":["cargo.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport shortid from 'shortid'\nimport Collection from './collection'\nimport AsyncNature from './async'\nimport schema from './schema'\nimport help from './helper'\n\n// Main Cargo idea.\n// All user ready-to-use \n// methods put here.\n\nclass Cargo extends AsyncNature {\n\n    public rusty: Function\n    public name: string\n    public dir: string\n    public schemas: Object\n\n    constructor(name: string, dir: string) {\n        super(this)\n        // Get path relative to the directory\n        if (dir && dir[0] === '~') {\n            dir = path.join(process.env.PWD, dir.slice(1))\n        }\n        // Provide a storage name 'string'\n        this.name = name || (() => { throw 'No storage name provided' })()\n        // Provide storage's location (optional) 'string'\n        this.dir = dir || process.env.PWD\n        // Create Base Folder Storage\n        help.createBase(this)\n        // Generate a better charset\n        shortid.characters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#$')\n        // Set default behavior for rusty containers\n        this.rusty = (location) => {\n            const name = path.basename(location)\n            console.error(help.textFormat(`\n                CargoDB stumbled upon a corrupted .cargo file.\n                In order to keep functioning the file is being renamed to\n                '${name}.rusty.cargo'.\n            `))\n        }\n        // Create variable to store all schemas\n        this.schemas = {}\n    }\n\n    // Whenever rusty container is found\n    // Run this callback with the path\n    public onRusty(cb: (path: string) => void) {\n        this.rusty = cb\n    }\n\n\n    // Set Item Method\n    // storage : String\n    // item : Any\n    public setCargo(storage: string, item: any): boolean {\n        // Location to the cargo file\n        const loc = path.join(\n            this.dir, this.name, storage + '.cargo'\n        )\n\n        // Validate if given name is correct\n        if (!help.validateName(storage)) {\n            throw `\n          Given name '${storage}' does not apply \n          to proper key name pattern\n          (RegExp: /^[A-Za-z0-9@$\\-#%&_()\\[\\]{}]+$/)\n        `\n        }\n\n        // Create container if does not exist\n        if (!fs.existsSync(loc)) {\n            fs.writeFileSync(loc, '{}')\n        }\n\n        // Get the already existing file\n        let objectContainer = fs.readFileSync(loc, 'utf-8')\n\n        // If it's a new file\n        if (objectContainer == null) {\n            fs.writeFileSync(loc, JSON.stringify({\n                [storage]: item\n            }))\n        }\n\n        // if the file actually exists \n        // to just \"append\" the data\n        else {\n            try {\n                // Try to parse JSON inside of the file\n                objectContainer = JSON.parse(objectContainer)\n                objectContainer[storage] = item\n                fs.writeFileSync(loc, JSON.stringify(objectContainer))\n            }\n            // if the data is corrupted\n            catch (err) {\n                // Location to the rusty cargo file\n                const rusty = path.join(\n                    this.dir, this.name, storage + '.rusty.cargo'\n                )\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path.join(this.dir, this.name, storage))\n                // Do the rename\n                fs.renameSync(loc, rusty)\n                // Save the value anyways\n                fs.writeFileSync(loc, JSON.stringify({ [storage]: item }))\n                return false\n            }\n\n        }\n        return true\n    }\n\n\n    // Get Item Method\n    // storage : String\n    public getCargo(storage: string): any {\n        // Location to the cargo file\n        const loc = path.join(\n            this.dir, this.name, storage + '.cargo'\n        )\n\n        // Validate if given name is correct\n        if (!help.validateName(storage)) {\n            throw `\n                Given name '${storage}' does not apply \n                to proper key name pattern\n                (RegExp: /^[A-Za-z0-9@$\\-#%&_()\\[\\]{}]+$/)\n            `\n        }\n\n        // If not exists then return undefined\n        if (fs.existsSync(loc)) {\n            try {\n                // Try to parse JSON inside of the file\n                let objectContainer = JSON.parse(fs.readFileSync(loc, 'utf-8'))\n                return objectContainer[storage]\n            }\n            // if the data is corrupted\n            catch (err) {\n                // Location to the rusty cargo file\n                const rusty = path.join(\n                    this.dir, this.name, storage + '.rusty.cargo'\n                )\n                // If there is rusty cargo handler\n                // notify user otherwise\n                this.rusty(path.join(this.dir, this.name, storage))\n                // Do the rename\n                fs.renameSync(loc, rusty)\n                return null\n            }\n        }\n        return null\n    }\n\n\n    // Get a collection (any)\n    // name : String\n    public in(name: string): Collection {\n        // Location to the collection dir\n        const loc = path.join(this.dir, this.name, name)\n\n        // Validate if given name is correct\n        if (!help.validateName(name)) {\n            throw `\n                Given name '${name}' does not apply \n                to proper key name pattern\n                (RegExp: /^[A-Za-z0-9@$\\-#%&_()\\[\\]{}]+$/)\n            `\n        }\n\n        if (this.schemas[name] == null) {\n            throw `\n                There is no collection with name: '${name}'\n                If this name is not a mistake,\n                create one with cargo.create()\n                (More info in docs)\n            `\n        }\n\n        return new Collection(loc, name, this.rusty, this.schemas[name])\n    }\n\n    // Create a collection\n    // Possibly with a schema\n    public create (\n        name: string, \n        schema: (\n            data: (value: string) => SchemaTag, \n            cache: (value: string) => SchemaTag, \n            ref: (value: string) => SchemaTag\n        ) => void | null\n    ) {\n        // Location to the collection dir\n        const loc = path.join(this.dir, this.name, name)\n        // Create dir if not exists\n        if (!fs.existsSync(loc)) {\n            fs.mkdirSync(loc)\n        }\n        // Create generic schema if nothing provided\n        if (schema == null) this.schemas[name] = 'no-schema'\n    }\n}\n\n\n// Async wrapper \n// for Cargo database.\n// Don't write any logic here\n// async wrapper's purpose is to\n// handle the code that needs to\n// be done asynchronously\n\nclass CargoAsync extends Cargo {\n    // Cargo constructor\n    constructor(name: string, path: string) {\n        super(name, path)\n    }\n\n    // Expose methods in a \n    // simple to use API\n\n    // Create a synchronous version of Cargo.\n    // Warning: possible collisions may occur\n    static Sync(name: string, path: string): Cargo {\n        return new Cargo(name, path)\n    }\n\n    // [Async] This method is used \n    // to set cargo to any value.\n    // The item can be any type.\n    public set(storage: string, item: any) {\n        return super.async('setCargo', [storage, item])\n    }\n\n    // [Sync] This method is used to \n    // retrieve data from a cargo.\n    // Returned null value means\n    // the cargo doesn't exist\n    public get(storage: string) {\n        return super.getCargo(storage)\n    }\n}\n\nexport default CargoAsync\nmodule.exports = CargoAsync"]}},"error":null,"hash":"43ea448afe3ec3d962ab0d2ff199ea9b","cacheData":{"env":{}}}